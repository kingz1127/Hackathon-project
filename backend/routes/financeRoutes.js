// Enhanced financeRoutes.js with proper database operations and receipts

import express from 'express';
import rateLimit from 'express-rate-limit';
import Payment from '../models/Payment.js';
import Receipt from '../models/Receipt.js';
import Student from '../models/Student.js';
import Transaction from '../models/Transaction.js';



// âœ… AUTOMATIC RECEIPT GENERATION FUNCTIONS - Add to your existing file

// Function to automatically generate receipt when payment is approved or created
const generateAutomaticReceipt = async (payment, actionType = 'approval') => {
  try {
    console.log(`ðŸ”„ Generating automatic receipt for ${actionType}:`, payment._id);
    
    // Only generate receipts for payments with actual paid amount
    if (payment.amountPaid <= 0) {
      console.log('â­ï¸ No amount paid, skipping automatic receipt generation');
      return null;
    }

    // Check if receipt already exists for this payment
    const existingReceipt = await Receipt.findOne({ paymentId: payment._id });
    
    if (existingReceipt) {
      console.log('ðŸ“ Updating existing receipt:', existingReceipt.receiptNumber);
      
      // Update existing receipt
      existingReceipt.amount = payment.amountPaid;
      existingReceipt.total = payment.amountPaid;
      existingReceipt.subtotal = payment.amountPaid;
      existingReceipt.items = [{
        description: payment.description,
        amount: payment.amountPaid,
        type: payment.type || 'tuition'
      }];
      existingReceipt.date = new Date();
      existingReceipt.status = 'completed';
      
      await existingReceipt.save();
      return existingReceipt;
    }

    // Generate new receipt
    const student = await Student.findOne({ studentId: payment.studentId });
    if (!student) {
      throw new Error(`Student not found: ${payment.studentId}`);
    }

    // Calculate balances
    const studentPayments = await Payment.find({ studentId: payment.studentId });
    const totalDue = studentPayments.reduce((sum, p) => sum + (p.amount || 0), 0);
    const totalPaid = studentPayments.reduce((sum, p) => sum + (p.amountPaid || 0), 0);
    const balanceRemaining = Math.max(0, totalDue - totalPaid);

    // Generate receipt number
    const receiptCount = await Receipt.countDocuments();
    const receiptNumber = `RCP-${String(receiptCount + 1).padStart(6, '0')}`;

    const receipt = new Receipt({
      receiptNumber,
      studentId: payment.studentId,
      studentName: student.fullName,
      studentEmail: student.email,
      studentCourse: student.course,
      paymentId: payment._id,
      amount: payment.amountPaid,
      description: payment.description,
      paymentMethod: 'approved_payment',
      status: 'completed',
      date: new Date(),
      items: [{
        description: payment.description,
        amount: payment.amountPaid,
        type: payment.type || 'tuition'
      }],
      subtotal: payment.amountPaid,
      tax: 0,
      total: payment.amountPaid,
      balanceInfo: {
        totalDue: totalDue,
        totalPaid: totalPaid,
        balanceRemaining: balanceRemaining
      },
      autoGenerated: true,
      generatedAt: new Date()
    });

    await receipt.save();
    
    // Update payment with receipt tracking
    await Payment.findByIdAndUpdate(payment._id, {
      receiptGenerated: true,
      receiptId: receipt._id,
      lastReceiptUpdate: new Date()
    });

    console.log('âœ… Automatic receipt generated:', receipt.receiptNumber);
    return receipt;

  } catch (error) {
    console.error('âŒ Error in automatic receipt generation:', error);
    throw error;
  }
};

// Function to generate receipt for new admin-created payments
const generateReceiptForNewPayment = async (paymentData) => {
  try {
    console.log('ðŸ”„ Generating receipt for new admin payment:', paymentData._id);
    
    const student = await Student.findOne({ studentId: paymentData.studentId });
    if (!student) {
      throw new Error(`Student not found: ${paymentData.studentId}`);
    }

    // Calculate balances
    const studentPayments = await Payment.find({ studentId: paymentData.studentId });
    const totalDue = studentPayments.reduce((sum, p) => sum + (p.amount || 0), 0);
    const totalPaid = studentPayments.reduce((sum, p) => sum + (p.amountPaid || 0), 0);
    const balanceRemaining = Math.max(0, totalDue - totalPaid);

    // Generate receipt number
    const receiptCount = await Receipt.countDocuments();
    const receiptNumber = `RCP-${String(receiptCount + 1).padStart(6, '0')}`;

    const receipt = new Receipt({
      receiptNumber,
      studentId: paymentData.studentId,
      studentName: student.fullName,
      studentEmail: student.email,
      studentCourse: student.course,
      paymentId: paymentData._id,
      amount: paymentData.amountPaid || paymentData.amount,
      description: paymentData.description,
      paymentMethod: 'admin_entry',
      status: 'completed',
      date: new Date(),
      items: [{
        description: paymentData.description,
        amount: paymentData.amountPaid || paymentData.amount,
        type: paymentData.type || 'tuition'
      }],
      subtotal: paymentData.amountPaid || paymentData.amount,
      tax: 0,
      total: paymentData.amountPaid || paymentData.amount,
      balanceInfo: {
        totalDue: totalDue,
        totalPaid: totalPaid,
        balanceRemaining: balanceRemaining
      },
      autoGenerated: true,
      generatedAt: new Date()
    });

    await receipt.save();
    
    // Update payment with receipt tracking
    await Payment.findByIdAndUpdate(paymentData._id, {
      receiptGenerated: true,
      receiptId: receipt._id,
      lastReceiptUpdate: new Date()
    });

    console.log('âœ… Receipt generated for new payment:', receipt.receiptNumber);
    return receipt;

  } catch (error) {
    console.error('âŒ Error generating receipt for new payment:', error);
    throw error;
  }
};

const router = express.Router();

const paymentLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 5, // limit each IP to 5 requests per windowMs
  message: 'Too many payment attempts, please try again later'
});

// âœ… Get all students for admin with real payment data
// In financeRoutes.js - UPDATED VERSION
router.get('/admin/students', async (req, res) => {
  try {
    console.log('Fetching all students for admin...');
    
    const students = await Student.find({ isActive: true })
      .select('studentId fullName email course gradeLevel')
      .lean();

    const studentsWithPayments = await Promise.all(
      students.map(async (student) => {
        const payments = await Payment.find({ studentId: student.studentId });
        
        // Calculate ONLY from payments, ignore student.accountBalance
        const totalAmount = payments.reduce((sum, payment) => sum + (payment.amount || 0), 0);
        const amountPaid = payments.reduce((sum, payment) => sum + (payment.amountPaid || 0), 0);
        
        return {
          id: student.studentId,
          name: student.fullName,
          email: student.email,
          course: student.course,
          gradeLevel: student.gradeLevel,
          totalAmount: totalAmount, // ONLY from payments
          amountPaid: amountPaid,   // ONLY from payments
          description: 'Tuition and Fees',
          payments: payments
        };
      })
    );

    console.log(`Found ${studentsWithPayments.length} students with payments`);
    res.json(studentsWithPayments);
  } catch (error) {
    console.error('Error fetching students for admin:', error);
    res.status(500).json({ message: 'Failed to fetch students', error: error.message });
  }
});

// âœ… Set payment for student with proper database saving
// // âœ… Set payment for student - FIXED VERSION
// router.post('/admin/set-payment', async (req, res) => {
//   try {
//     const { studentId, studentName, amount, description, dueDate, type } = req.body;
    
//     console.log('Setting payment for student:', { studentId, studentName, amount, description, dueDate, type });

//     // Validate input
//     if (!studentId || !studentName || !amount || !description || !dueDate) {
//       return res.status(400).json({ message: 'All fields are required' });
//     }

//     // Check if student exists
//     const student = await Student.findOne({ studentId });
//     if (!student) {
//       return res.status(404).json({ message: 'Student not found' });
//     }

//     // âœ… FIX: Include studentName in the payment creation
//     const payment = new Payment({
//       studentId,
//       studentName: studentName, // âœ… ADD THIS - it's now required in the model
//       amount: parseFloat(amount),
//       amountPaid: 0,
//       description,
//       dueDate: new Date(dueDate),
//       type: type || 'tuition',
//       status: 'pending'
//     });

//     await payment.save();

//     // Update student's account balance
//     student.accountBalance = (student.accountBalance || 0) + parseFloat(amount);
//     student.lastUpdated = new Date();
//     await student.save();

//     // Create transaction record
//     const transaction = new Transaction({
//       transactionId: `TXN${Date.now()}`,
//       studentId,
//       studentName: student.fullName,
//       description: `Payment assigned: ${description}`,
//       amount: parseFloat(amount),
//       type: 'payment',
//       status: 'pending',
//       date: new Date(),
//       paymentId: payment._id,
//       balanceBefore: (student.accountBalance || 0) - parseFloat(amount),
//       balanceAfter: student.accountBalance
//     });

//     await transaction.save();

//     console.log('Payment set successfully for student:', studentId);
//     res.json({ 
//       message: 'Payment successfully set for student', 
//       payment,
//       transaction
//     });
//   } catch (error) {
//     console.error('Error setting payment:', error);
//     res.status(500).json({ message: 'Failed to set payment', error: error.message });
//   }
// });

// âœ… Set payment for student - FIXED VERSION
// âœ… Set payment for student - UPDATED to keep payments as pending
// âœ… Set payment for student - WITHOUT transaction creation
router.post('/admin/set-payment', async (req, res) => {
  try {
    const { studentId, studentName, amount, description, dueDate, type } = req.body;
    
    console.log('Setting payment for student:', { studentId, studentName, amount, description, dueDate, type });

    // Validate input
    if (!studentId || !studentName || !amount || !description || !dueDate) {
      return res.status(400).json({ message: 'All fields are required' });
    }

    // Check if student exists
    const student = await Student.findOne({ studentId });
    if (!student) {
      return res.status(404).json({ message: 'Student not found' });
    }

    // Create payment with amountPaid = 0 and status = 'pending'
    const payment = new Payment({
      studentId,
      studentName: studentName,
      amount: parseFloat(amount),
      amountPaid: 0, // âœ… Start with 0 paid
      description,
      dueDate: new Date(dueDate),
      type: type || 'tuition',
      status: 'pending' // âœ… Set as pending, not completed
    });

    await payment.save();

    // Update student's account balance (only add to total due, not paid)
    student.accountBalance = (student.accountBalance || 0) + parseFloat(amount);
    student.lastUpdated = new Date();
    await student.save();

    // âœ… REMOVED: Transaction creation for payment assignment
    // We only create transactions when actual payments are made

    console.log('Payment set successfully for student:', studentId);
    res.json({ 
      message: 'Payment successfully set for student', 
      payment
      // No transaction returned for assignment
    });
  } catch (error) {
    console.error('Error setting payment:', error);
    res.status(500).json({ message: 'Failed to set payment', error: error.message });
  }
});



// âœ… Edit payment with all fields - UPDATED for proper amount handling
router.put('/admin/edit-payment/:paymentId', async (req, res) => {
  try {
    const { paymentId } = req.params;
    const { amountPaid, totalAmount, status, description, dueDate, type } = req.body;
    
    console.log('Editing payment:', { paymentId, amountPaid, totalAmount, status, description, dueDate, type });

    const payment = await Payment.findById(paymentId);
    if (!payment) {
      return res.status(404).json({ message: 'Payment not found' });
    }

    const oldAmountPaid = payment.amountPaid || 0;
    const newAmountPaid = parseFloat(amountPaid) || 0;
    const newTotalAmount = parseFloat(totalAmount) || payment.amount;

    // Update payment with all fields
    payment.amountPaid = newAmountPaid;
    payment.amount = newTotalAmount;
    payment.status = status || payment.status;
    payment.description = description || payment.description;
    payment.dueDate = dueDate ? new Date(dueDate) : payment.dueDate;
    payment.type = type || payment.type;
    payment.updatedAt = new Date();

    await payment.save();

    // âœ… AUTOMATIC RECEIPT GENERATION for paid amounts
    let receipt = null;
    if (newAmountPaid > 0 && newAmountPaid !== oldAmountPaid) {
      try {
        receipt = await generateAutomaticReceipt(payment, 'admin_edit');
        console.log('âœ… Automatic receipt generated during payment edit');
      } catch (receiptError) {
        console.error('âŒ Automatic receipt generation failed:', receiptError);
      }
    }

    // Update student's account balance based on payments
    const student = await Student.findOne({ studentId: payment.studentId });
    if (student) {
      // Recalculate balance from all payments
      const allPayments = await Payment.find({ studentId: payment.studentId });
      const totalDue = allPayments.reduce((sum, p) => sum + (p.amount || 0), 0);
      const totalPaid = allPayments.reduce((sum, p) => sum + (p.amountPaid || 0), 0);
      
      student.accountBalance = totalDue - totalPaid;
      student.lastUpdated = new Date();
      await student.save();

      // Create transaction if payment amount changed
      if (newAmountPaid !== oldAmountPaid) {
        const transaction = new Transaction({
          transactionId: `TXN${Date.now()}`,
          studentId: payment.studentId,
          studentName: payment.studentName,
          description: `Payment updated: ${payment.description}`,
          amount: newAmountPaid - oldAmountPaid,
          type: 'payment',
          status: 'completed',
          date: new Date(),
          paymentId: payment._id,
          balanceBefore: student.accountBalance + (newAmountPaid - oldAmountPaid),
          balanceAfter: student.accountBalance
        });
        await transaction.save();
      }
    }

    console.log('Payment updated successfully:', paymentId);
    res.json({ 
      message: 'Payment successfully updated', 
      payment,
      receipt: receipt ? {
        id: receipt._id,
        receiptNumber: receipt.receiptNumber,
        total: receipt.total
      } : null
    });
  } catch (error) {
    console.error('Error updating payment:', error);
    res.status(500).json({ message: 'Failed to update payment', error: error.message });
  }
});

// âœ… Update the receipt generation in financeRoutes.js

// âœ… Generate receipt function - COMPLETE VERSION with proper student data and balances
const generateReceipt = async (payment, amountPaid, paymentMethod = 'Online') => {
  try {
    const student = await Student.findOne({ studentId: payment.studentId });
    
    if (!student) {
      throw new Error(`Student not found: ${payment.studentId}`);
    }
    
    // âœ… Calculate proper balances for the student
    const studentPayments = await Payment.find({ studentId: payment.studentId });
    const totalDue = studentPayments.reduce((sum, p) => sum + (p.amount || 0), 0);
    const totalPaid = studentPayments.reduce((sum, p) => sum + (p.amountPaid || 0), 0);
    const balanceRemaining = Math.max(0, totalDue - totalPaid);

    const receipt = new Receipt({
      studentId: payment.studentId,
      studentName: student.fullName,
      studentEmail: student.email,
      studentCourse: student.course,
      paymentId: payment._id,
      amount: amountPaid,
      description: payment.description,
      paymentMethod: paymentMethod,
      status: 'completed',
      date: new Date(),
      items: [{
        description: payment.description,
        amount: amountPaid,
        type: payment.type || 'tuition'
      }],
      subtotal: amountPaid,
      tax: 0,
      total: amountPaid,
      balanceInfo: {  // âœ… Store balance information in receipt
        totalDue: totalDue,
        totalPaid: totalPaid,
        balanceRemaining: balanceRemaining
      }
    });

    await receipt.save();
    console.log('âœ… Receipt generated with complete info:', {
      receiptNumber: receipt.receiptNumber,
      student: receipt.studentName,
      email: receipt.studentEmail,
      course: receipt.studentCourse,
      totalDue: totalDue,
      totalPaid: totalPaid,
      balanceRemaining: balanceRemaining
    });
    return receipt;
  } catch (error) {
    console.error('âŒ Error generating receipt:', error);
    throw error;
  }
};

// âœ… Generate receipts for existing payments
router.post('/admin/generate-missing-receipts', async (req, res) => {
  try {
    console.log('Generating missing receipts for existing payments...');
    
    // Find payments that don't have receipts yet
    const payments = await Payment.find({ 
      $or: [
        { amountPaid: { $gt: 0 } },
        { status: 'completed' }
      ]
    });
    
    console.log(`Found ${payments.length} payments to generate receipts for`);
    
    const generatedReceipts = [];
    
    for (const payment of payments) {
      // Check if receipt already exists for this payment
      const existingReceipt = await Receipt.findOne({ paymentId: payment._id });
      
      if (!existingReceipt) {
        // Generate receipt
        const receipt = await generateReceipt(
          payment, 
          payment.amountPaid || payment.amount,
          'System Generated'
        );
        
        generatedReceipts.push(receipt);
        console.log(`Generated receipt for payment: ${payment.description}`);
      }
    }
    
    res.json({
      message: `Successfully generated ${generatedReceipts.length} receipts`,
      generatedReceipts: generatedReceipts.length,
      totalPayments: payments.length
    });
    
  } catch (error) {
    console.error('Error generating missing receipts:', error);
    res.status(500).json({ 
      message: 'Failed to generate receipts', 
      error: error.message 
    });
  }
});

// âœ… Get payment details for a specific payment
router.get('/admin/payment/:paymentId', async (req, res) => {
  try {
    const { paymentId } = req.params;
    const payment = await Payment.findById(paymentId);
    
    if (!payment) {
      return res.status(404).json({ message: 'Payment not found' });
    }

    res.json(payment);
  } catch (error) {
    console.error('Error fetching payment:', error);
    res.status(500).json({ message: 'Failed to fetch payment', error: error.message });
  }
});

// âœ… Get all payments for admin
router.get('/admin/payments', async (req, res) => {
  try {
    const payments = await Payment.find().sort({ createdAt: -1 });
    res.json(payments);
  } catch (error) {
    console.error('Error fetching payments:', error);
    res.status(500).json({ message: 'Failed to fetch payments', error: error.message });
  }
});

// âœ… NEW: Generate receipt for transaction
router.post('/admin/generate-receipt/:transactionId', async (req, res) => {
  try {
    const { transactionId } = req.params;
    
    console.log('ðŸ”„ Generating receipt for transaction:', transactionId);

    // Find the transaction
    const transaction = await Transaction.findById(transactionId);
    if (!transaction) {
      return res.status(404).json({ 
        success: false, 
        message: 'Transaction not found' 
      });
    }

    // Check if receipt already exists
    const existingReceipt = await Receipt.findOne({ transactionId });
    if (existingReceipt) {
      return res.json({
        success: true,
        message: 'Receipt already exists',
        receipt: existingReceipt
      });
    }

    // Get student information
    const student = await Student.findOne({ studentId: transaction.studentId });
    if (!student) {
      return res.status(404).json({ 
        success: false, 
        message: 'Student not found' 
      });
    }

    // Get payment information
    const payment = await Payment.findById(transaction.paymentId);

    // Calculate balances
    const studentPayments = await Payment.find({ studentId: transaction.studentId });
    const totalDue = studentPayments.reduce((sum, p) => sum + (p.amount || 0), 0);
    const totalPaid = studentPayments.reduce((sum, p) => sum + (p.amountPaid || 0), 0);
    const balanceRemaining = Math.max(0, totalDue - totalPaid);

    // Create new receipt
    const receipt = new Receipt({
      receiptNumber: `RCP-${Date.now()}-${Math.random().toString(36).substr(2, 6).toUpperCase()}`,
      studentId: transaction.studentId,
      studentName: student.fullName,
      studentEmail: student.email,
      studentCourse: student.course,
      transactionId: transaction._id,
      paymentId: transaction.paymentId,
      amount: Math.abs(transaction.amount),
      description: transaction.description,
      paymentMethod: transaction.paymentMethod || 'Online',
      status: 'completed',
      date: transaction.transactionDate || new Date(),
      items: [{
        description: payment?.description || transaction.description,
        amount: Math.abs(transaction.amount),
        type: payment?.type || 'payment'
      }],
      subtotal: Math.abs(transaction.amount),
      tax: 0,
      total: Math.abs(transaction.amount),
      balanceInfo: {
        totalDue: totalDue,
        totalPaid: totalPaid,
        balanceRemaining: balanceRemaining
      }
    });

    await receipt.save();
    console.log('âœ… Receipt generated successfully:', receipt.receiptNumber);

    res.json({
      success: true,
      message: 'Receipt generated successfully',
      receipt: receipt
    });

  } catch (error) {
    console.error('âŒ Error generating receipt:', error);
    res.status(500).json({ 
      success: false, 
      message: 'Failed to generate receipt', 
      error: error.message 
    });
  }
});

// âœ… Generate and send receipt to student
router.post('/admin/generate-receipt/:paymentId', async (req, res) => {
  try {
    const { paymentId } = req.params;
    const payment = await Payment.findById(paymentId);
    
    if (!payment) {
      return res.status(404).json({ message: 'Payment not found' });
    }

    const receipt = await generateReceipt(payment, payment.amountPaid || payment.amount);
    
    res.json({
      message: 'Receipt generated successfully',
      receipt
    });
  } catch (error) {
    console.error('Error generating receipt:', error);
    res.status(500).json({ message: 'Failed to generate receipt', error: error.message });
  }
});

/// âœ… Get financial overview for admin - FIXED VERSION
// router.get('/admin/overview', async (req, res) => {
//   try {
//     const students = await Student.find({ isActive: true });
//     const payments = await Payment.find();
//     const transactions = await Transaction.find().sort({ createdAt: -1 }).limit(10);
//     const receipts = await Receipt.find().sort({ date: -1 }).limit(8);

//     // Calculate financial metrics from ACTUAL payments
//     const totalRevenue = payments
//       .reduce((sum, payment) => sum + (payment.amountPaid || 0), 0);

//     const pendingPayments = payments
//       .filter(p => p.status === 'pending' || p.status === 'due')
//       .reduce((sum, payment) => sum + (payment.amount || 0), 0);

//     const collectedThisMonth = payments
//       .filter(p => p.amountPaid > 0 && 
//         new Date(p.updatedAt).getMonth() === new Date().getMonth())
//       .reduce((sum, payment) => sum + (payment.amountPaid || 0), 0);

//     // âœ… FIX: Calculate outstanding balance from payments, not student.accountBalance
//     const outstandingBalance = payments.reduce((sum, payment) => {
//       return sum + (payment.amount || 0) - (payment.amountPaid || 0);
//     }, 0);

//     // Payment distribution by type
//     const paymentDistribution = [
//       { category: 'Tuition', amount: 0, percentage: 0, color: '#3b82f6' },
//       { category: 'Housing', amount: 0, percentage: 0, color: '#ef4444' },
//       { category: 'Meal Plan', amount: 0, percentage: 0, color: '#10b981' },
//       { category: 'Fees', amount: 0, percentage: 0, color: '#f59e0b' }
//     ];

//     payments.forEach(payment => {
//       const categoryIndex = paymentDistribution.findIndex(item => 
//         item.category.toLowerCase() === (payment.type || 'tuition')?.toLowerCase()
//       );
//       if (categoryIndex !== -1) {
//         paymentDistribution[categoryIndex].amount += payment.amount || 0;
//       }
//     });

//     // Calculate percentages
//     const totalAmount = paymentDistribution.reduce((sum, item) => sum + item.amount, 0);
//     paymentDistribution.forEach(item => {
//       item.percentage = totalAmount > 0 ? Math.round((item.amount / totalAmount) * 100) : 0;
//     });

//     // âœ… FIX: Top students with balances calculated from payments
//     const studentBalances = await Promise.all(
//       students.map(async (student) => {
//         const studentPayments = await Payment.find({ studentId: student.studentId });
//         const balance = studentPayments.reduce((sum, payment) => {
//           return sum + (payment.amount || 0) - (payment.amountPaid || 0);
//         }, 0);
        
//         return {
//           id: student.studentId,
//           name: student.fullName,
//           balance: balance,
//           status: balance > 1000 ? 'Overdue' : balance > 0 ? 'Due Soon' : 'Paid'
//         };
//       })
//     );

//     const enhancedTransactions = await Promise.all(
//       transactions.map(async (transaction) => {
//         let studentName = 'Student';
//         let studentId = transaction.studentId || 'N/A';
        
//         // Fetch student details if studentId exists
//         if (transaction.studentId) {
//           const student = await Student.findOne({ studentId: transaction.studentId });
//           if (student) {
//             studentName = student.fullName;
//             studentId = student.studentId;
//           }
//         }

//         return {
//           id: transaction._id,
//           student: studentName,
//           studentId: studentId,
//           description: transaction.description,
//           amount: transaction.amount,
//           date: transaction.transactionDate || transaction.createdAt,
//           type: transaction.type,
//           status: transaction.status
//         };
//       })
//     );

//     const topStudents = studentBalances
//       .filter(student => student.balance > 0)
//       .sort((a, b) => b.balance - a.balance)
//       .slice(0, 5);

//     const overviewData = {
//       totalRevenue,
//       revenueTrend: totalRevenue > 0 ? 12.5 : 0,
//       pendingPayments,
//       collectedThisMonth,
//       outstandingBalance,
//       collectionRate: totalRevenue > 0 ? Math.round((totalRevenue / (totalRevenue + outstandingBalance)) * 100) : 0,
//       paymentDistribution: paymentDistribution.filter(item => item.amount > 0),
//       topStudents,
//       recentTransactions: enhancedTransactions, // âœ… Use enhanced transactions
//       receipts: receipts.map(receipt => ({
//         id: receipt._id,
//         receiptNumber: receipt.receiptNumber,
//         student: receipt.studentName,
//         studentId: receipt.studentId,
//         date: receipt.date,
//         time: receipt.date.toLocaleTimeString(),
//         total: receipt.total,
//         status: receipt.status,
//         paymentMethod: receipt.paymentMethod,
//         items: receipt.items || []
//       }))
//     };

//     res.json(overviewData);
//   } catch (error) {
//     console.error('Error fetching admin overview:', error);
//     res.status(500).json({ message: 'Failed to fetch overview', error: error.message });
//   }
// });

/// âœ… Get financial overview for admin - FIXED TRANSACTIONS VERSION
router.get('/admin/overview', async (req, res) => {
  try {
    const students = await Student.find({ isActive: true });
    const payments = await Payment.find();
    
    // âœ… FIX: Get transactions with proper sorting and field mapping
    const transactions = await Transaction.find()
      .sort({ date: -1, createdAt: -1 })  // Sort by date first, then creation time
      .limit(10);

    const receipts = await Receipt.find().sort({ date: -1 }).limit(8);

    // Calculate financial metrics from ACTUAL payments
    const totalRevenue = payments
      .reduce((sum, payment) => sum + (payment.amountPaid || 0), 0);

    const pendingPayments = payments
      .filter(p => p.status === 'pending' || p.status === 'due')
      .reduce((sum, payment) => sum + (payment.amount || 0), 0);

    const collectedThisMonth = payments
      .filter(p => p.amountPaid > 0 && 
        new Date(p.updatedAt).getMonth() === new Date().getMonth())
      .reduce((sum, payment) => sum + (payment.amountPaid || 0), 0);

    // Calculate outstanding balance from payments
    const outstandingBalance = payments.reduce((sum, payment) => {
      return sum + (payment.amount || 0) - (payment.amountPaid || 0);
    }, 0);

    // Payment distribution by type
    const paymentDistribution = [
      { category: 'Tuition', amount: 0, percentage: 0, color: '#3b82f6' },
      { category: 'Housing', amount: 0, percentage: 0, color: '#ef4444' },
      { category: 'Meal Plan', amount: 0, percentage: 0, color: '#10b981' },
      { category: 'Fees', amount: 0, percentage: 0, color: '#f59e0b' }
    ];

    payments.forEach(payment => {
      const categoryIndex = paymentDistribution.findIndex(item => 
        item.category.toLowerCase() === (payment.type || 'tuition')?.toLowerCase()
      );
      if (categoryIndex !== -1) {
        paymentDistribution[categoryIndex].amount += payment.amount || 0;
      }
    });

    // Calculate percentages
    const totalAmount = paymentDistribution.reduce((sum, item) => sum + item.amount, 0);
    paymentDistribution.forEach(item => {
      item.percentage = totalAmount > 0 ? Math.round((item.amount / totalAmount) * 100) : 0;
    });

    // Top students with balances calculated from payments
    const studentBalances = await Promise.all(
      students.map(async (student) => {
        const studentPayments = await Payment.find({ studentId: student.studentId });
        const balance = studentPayments.reduce((sum, payment) => {
          return sum + (payment.amount || 0) - (payment.amountPaid || 0);
        }, 0);
        
        return {
          id: student.studentId,
          name: student.fullName,
          balance: balance,
          status: balance > 1000 ? 'Overdue' : balance > 0 ? 'Due Soon' : 'Paid'
        };
      })
    );

    // âœ… FIX: Enhanced transactions with proper field mapping
    const enhancedTransactions = await Promise.all(
      transactions.map(async (transaction) => {
        let studentName = transaction.studentName || 'Student';
        let studentId = transaction.studentId || 'N/A';
        
        // Fetch student details if needed
        if (transaction.studentId && !transaction.studentName) {
          const student = await Student.findOne({ studentId: transaction.studentId });
          if (student) {
            studentName = student.fullName;
          }
        }

        return {
          id: transaction._id,
          student: studentName,
          studentId: studentId,
          description: transaction.description,
          amount: transaction.amount,
          date: transaction.date || transaction.createdAt, // âœ… Use date field
          type: transaction.type,
          status: transaction.status,
          transactionId: transaction.transactionId // âœ… Include transaction ID
        };
      })
    );

    const topStudents = studentBalances
      .filter(student => student.balance > 0)
      .sort((a, b) => b.balance - a.balance)
      .slice(0, 5);

    const overviewData = {
      totalRevenue,
      revenueTrend: totalRevenue > 0 ? 12.5 : 0,
      pendingPayments,
      collectedThisMonth,
      outstandingBalance,
      collectionRate: totalRevenue > 0 ? Math.round((totalRevenue / (totalRevenue + outstandingBalance)) * 100) : 0,
      paymentDistribution: paymentDistribution.filter(item => item.amount > 0),
      topStudents,
      recentTransactions: enhancedTransactions,
      receipts: receipts.map(receipt => ({
        id: receipt._id,
        receiptNumber: receipt.receiptNumber,
        student: receipt.studentName,
        studentId: receipt.studentId,
        date: receipt.date,
        time: receipt.date.toLocaleTimeString(),
        total: receipt.total,
        status: receipt.status,
        paymentMethod: receipt.paymentMethod,
        items: receipt.items || []
      }))
    };

    console.log(`ðŸ“Š Overview: ${enhancedTransactions.length} transactions loaded`);
    res.json(overviewData);
  } catch (error) {
    console.error('Error fetching admin overview:', error);
    res.status(500).json({ message: 'Failed to fetch overview', error: error.message });
  }
});

// âœ… Get all receipts with filtering (replace existing one)
router.get('/admin/receipts', async (req, res) => {
  try {
    const { period, search } = req.query;
    
    console.log('Fetching receipts with filters:', { period, search });
    
    let query = {};
    
    // Date filtering based on period
    if (period) {
      const now = new Date();
      let startDate;
      
      switch (period) {
        case 'month':
          startDate = new Date(now.getFullYear(), now.getMonth(), 1);
          break;
        case 'quarter':
          startDate = new Date(now.getFullYear(), now.getMonth() - 3, 1);
          break;
        case 'year':
          startDate = new Date(now.getFullYear(), 0, 1);
          break;
        default:
          // All receipts
          break;
      }
      
      if (startDate) {
        query.date = { $gte: startDate };
      }
    }
    
    // Search filtering
    if (search) {
      query.$or = [
        { studentName: { $regex: search, $options: 'i' } },
        { studentId: { $regex: search, $options: 'i' } },
        { receiptNumber: { $regex: search, $options: 'i' } }
      ];
    }
    
    const receipts = await Receipt.find(query)
      .sort({ date: -1 })
      .limit(50);
    
    console.log(`Found ${receipts.length} receipts`);
    
    const formattedReceipts = receipts.map(receipt => {
      // âœ… FIX: Ensure we have a valid date
      const receiptDate = receipt.date || new Date();
      
      return {
        id: receipt._id,
        receiptNumber: receipt.receiptNumber,
        student: receipt.studentName,
        studentId: receipt.studentId,
        date: receiptDate,
        time: new Date(receiptDate).toLocaleTimeString(), // âœ… FIXED: Use Date object
        total: receipt.total,
        status: receipt.status,
        paymentMethod: receipt.paymentMethod,
        items: receipt.items || []
      };
    });
    
    res.json({
      success: true,
      receipts: formattedReceipts,
      total: receipts.length
    });
    
  } catch (error) {
    console.error('Error fetching receipts:', error);
    res.status(500).json({ 
      success: false,
      message: 'Failed to fetch receipts', 
      error: error.message 
    });
  }
});

/// âœ… Get student financial overview - FIXED TRANSACTIONS VERSION
router.get('/student/:studentId/overview', async (req, res) => {
  try {
    const { studentId } = req.params;
    console.log(`Fetching financial overview for student: ${studentId}`);

    // Check if student exists
    const student = await Student.findOne({ studentId });
    if (!student) {
      return res.status(404).json({ message: 'Student not found' });
    }

    // Get student's payments
    const payments = await Payment.find({ studentId });
    
    // âœ… FIX: Get recent transactions for this student with proper sorting
    const recentTransactions = await Transaction.find({ studentId })
      .sort({ date: -1, createdAt: -1 }) // Sort by date and creation time
      .limit(10)
      .select('description amount date status type paymentMethod studentName');

    console.log(`ðŸ“Š Found ${recentTransactions.length} transactions for student ${studentId}`);

    // Get upcoming due payments
    const upcomingPayments = payments
      .filter(payment => 
        (payment.status === 'pending' || payment.status === 'due' || payment.status === 'partial') &&
        payment.amount > 0
      )
      .sort((a, b) => new Date(a.dueDate) - new Date(b.dueDate))
      .slice(0, 5);

    // Calculate financial metrics
    const totalDue = payments.reduce((sum, payment) => sum + (payment.amount || 0), 0);
    const amountPaid = payments.reduce((sum, payment) => sum + (payment.amountPaid || 0), 0);
    const amountRemaining = totalDue - amountPaid;

    // Calculate payment distribution
    const paymentDistribution = [
      { category: 'Tuition', amount: 0, percentage: 0, color: '#3b82f6' },
      { category: 'Housing', amount: 0, percentage: 0, color: '#ef4444' },
      { category: 'Meal Plan', amount: 0, percentage: 0, color: '#10b981' },
      { category: 'Fees', amount: 0, percentage: 0, color: '#f59e0b' }
    ];

    payments.forEach(payment => {
      const categoryIndex = paymentDistribution.findIndex(item => 
        item.category.toLowerCase() === (payment.type || 'tuition')?.toLowerCase()
      );
      if (categoryIndex !== -1) {
        paymentDistribution[categoryIndex].amount += payment.amount || 0;
      }
    });

    // Filter out empty categories
    const filteredPaymentDistribution = paymentDistribution.filter(item => item.amount > 0);

    // Calculate percentages
    const totalAmount = filteredPaymentDistribution.reduce((sum, item) => sum + item.amount, 0);
    filteredPaymentDistribution.forEach(item => {
      item.percentage = totalAmount > 0 ? Math.round((item.amount / totalAmount) * 100) : 0;
    });

    // âœ… FIX: Format transactions properly
    const formattedTransactions = recentTransactions.map(transaction => ({
      id: transaction._id,
      description: transaction.description,
      amount: transaction.amount,
      date: transaction.date || transaction.createdAt,
      type: transaction.type,
      status: transaction.status,
      paymentMethod: transaction.paymentMethod
    }));

    const studentOverview = {
      studentInfo: {
        id: student.studentId,
        name: student.fullName,
        email: student.email,
        course: student.course,
        gradeLevel: student.gradeLevel
      },
      financialSummary: {
        totalDue,
        amountPaid,
        amountRemaining,
        accountBalance: student.accountBalance || 0,
        paymentProgress: totalDue > 0 ? Math.round((amountPaid / totalDue) * 100) : 0
      },
      paymentDistribution: filteredPaymentDistribution,
      upcomingPayments: upcomingPayments,
      recentTransactions: formattedTransactions, // âœ… Use formatted transactions
      paymentHistory: payments.map(payment => ({
        id: payment._id,
        description: payment.description,
        totalAmount: payment.amount,
        amountPaid: payment.amountPaid,
        dueDate: payment.dueDate,
        status: payment.status,
        type: payment.type,
        createdAt: payment.createdAt
      }))
    };

    console.log(`âœ… Student overview fetched successfully for: ${studentId}`);
    res.json(studentOverview);
  } catch (error) {
    console.error('Error fetching student overview:', error);
    res.status(500).json({ 
      message: 'Failed to fetch student financial overview', 
      error: error.message 
    });
  }
});


// âœ… Get student payment history
router.get('/student/:studentId/payments', async (req, res) => {
  try {
    const { studentId } = req.params;
    console.log(`Fetching payments for student: ${studentId}`);

    // Validate student exists
    const student = await Student.findOne({ studentId });
    if (!student) {
      return res.status(404).json({ 
        success: false, 
        message: 'Student not found' 
      });
    }

    // Get payments for this student
    const payments = await Payment.find({ studentId }).sort({ dueDate: 1 });
    
    console.log(`Found ${payments.length} payments for student ${studentId}`);
    
    res.json({
      success: true,
      student: {
        id: student.studentId,
        name: student.fullName,
        email: student.email
      },
      payments: payments.map(payment => ({
        id: payment._id,
        studentId: payment.studentId,
        studentName: payment.studentName,
        amount: payment.amount,
        amountPaid: payment.amountPaid,
        totalAmount: payment.amount,
        description: payment.description,
        dueDate: payment.dueDate,
        type: payment.type,
        status: payment.status,
        createdAt: payment.createdAt,
        updatedAt: payment.updatedAt
      }))
    });
  } catch (error) {
    console.error('Error fetching student payments:', error);
    res.status(500).json({ 
      success: false, 
      message: 'Error fetching student payments', 
      error: error.message 
    });
  }
});

// âœ… FIXED: Get student receipts - ENHANCED VERSION
router.get('/student/:studentId/receipts', async (req, res) => {
  try {
    const { studentId } = req.params;
    
    console.log('ðŸ“„ Fetching receipts for student:', studentId);
    
    // Get receipts for this student
    const receipts = await Receipt.find({ studentId }).sort({ date: -1 });
    
    console.log(`âœ… Found ${receipts.length} receipts for student ${studentId}`);
    
    res.json({
      success: true,
      receipts: receipts.map(receipt => ({
        id: receipt._id,
        receiptNumber: receipt.receiptNumber,
        student: receipt.studentName,
        studentId: receipt.studentId,
        studentEmail: receipt.studentEmail,
        studentCourse: receipt.studentCourse,
        amount: receipt.amount,
        description: receipt.description,
        date: receipt.date,
        status: receipt.status,
        paymentMethod: receipt.paymentMethod,
        items: receipt.items,
        subtotal: receipt.subtotal,
        tax: receipt.tax,
        total: receipt.total,
        balanceInfo: receipt.balanceInfo,
        sentToStudent: receipt.sentToStudent,
        sentAt: receipt.sentAt
      }))
    });
  } catch (error) {
    console.error('Error fetching student receipts:', error);
    res.status(500).json({ 
      success: false, 
      message: 'Error fetching student receipts', 
      error: error.message 
    });
  }
});


// âœ… Make payment (student paying their dues)
router.post('/student/:studentId/make-payment', paymentLimiter, async (req, res) => {
  try {
    const { studentId } = req.params;
    const { paymentId, amount, paymentMethod } = req.body;

    console.log(`Processing payment for student ${studentId}:`, { paymentId, amount, paymentMethod });

    // Validate input
    if (!paymentId || !amount || !paymentMethod) {
      return res.status(400).json({ 
        success: false, 
        message: 'Payment ID, amount, and payment method are required' 
      });
    }

    // Find the payment
    const payment = await Payment.findById(paymentId);
    if (!payment || payment.studentId !== studentId) {
      return res.status(404).json({ 
        success: false, 
        message: 'Payment not found' 
      });
    }

    const paymentAmount = parseFloat(amount);
    const remainingBalance = payment.amount - payment.amountPaid;

    // Validate payment amount
    if (paymentAmount <= 0 || paymentAmount > remainingBalance) {
      return res.status(400).json({ 
        success: false, 
        message: `Invalid payment amount. Maximum allowed: ${remainingBalance}` 
      });
    }

    // Update payment
    payment.amountPaid += paymentAmount;
    
    // Update status based on payment
    if (payment.amountPaid >= payment.amount) {
      payment.status = 'completed';
    } else if (payment.amountPaid > 0) {
      payment.status = 'partial';
    }
    
    payment.updatedAt = new Date();
    await payment.save();

    // âœ… ADD AUTOMATIC RECEIPT GENERATION HERE
    let receipt = null;
    try {
      receipt = await generateAutomaticReceipt(payment, 'student_payment');
      console.log('âœ… Automatic receipt generated for student payment');
    } catch (receiptError) {
      console.error('âŒ Automatic receipt generation failed:', receiptError);
      // Continue even if receipt generation fails
    }

    // Update student balance
    const student = await Student.findOne({ studentId });
    if (student) {
      student.accountBalance = Math.max(0, (student.accountBalance || 0) - paymentAmount);
      student.lastUpdated = new Date();
      await student.save();
    }

    // Create transaction record
    const transaction = new Transaction({
      transactionId: `TXN${Date.now()}`,
      studentId,
      studentName: student.fullName,
      description: `Payment made: ${payment.description}`,
      amount: paymentAmount,
      type: 'payment',
      status: 'completed',
      date: new Date(),
      paymentId: payment._id,
      paymentMethod: paymentMethod,
      balanceBefore: (student.accountBalance || 0) + paymentAmount,
      balanceAfter: student.accountBalance
    });
    await transaction.save();

    console.log(`Payment processed successfully for student ${studentId}`);
    res.json({
      success: true,
      message: 'Payment processed successfully',
      payment,
      transaction,
      receipt: receipt ? {
        id: receipt._id,
        receiptNumber: receipt.receiptNumber,
        total: receipt.total
      } : null
    });
  } catch (error) {
    console.error('Error processing payment:', error);
    res.status(500).json({ 
      success: false, 
      message: 'Failed to process payment', 
      error: error.message 
    });
  }
});

// Add this to clear ALL finance data
router.delete('/admin/clear-all-data', async (req, res) => {
  try {
    await Payment.deleteMany({});
    await Transaction.deleteMany({});
    await Receipt.deleteMany({});
    
    // Also reset student balances
    await Student.updateMany({}, { $set: { accountBalance: 0 } });
    
    res.json({ 
      message: 'All finance data cleared successfully',
      cleared: {
        payments: true,
        transactions: true,
        receipts: true,
        studentBalances: true
      }
    });
  } catch (error) {
    console.error('Error clearing finance data:', error);
    res.status(500).json({ message: 'Failed to clear data', error: error.message });
  }
});

/// âœ… Generate receipt from payment data - UPDATED with complete student info
router.get('/payment/:paymentId/receipt', async (req, res) => {
  try {
    const { paymentId } = req.params;
    
    console.log('Generating receipt for payment:', paymentId);
    
    // Find the payment
    const payment = await Payment.findById(paymentId);
    if (!payment) {
      return res.status(404).json({ message: 'Payment not found' });
    }

    // Get student information
    const student = await Student.findOne({ studentId: payment.studentId });
    if (!student) {
      return res.status(404).json({ message: 'Student not found' });
    }

    // Calculate remaining balance for the student
    const studentPayments = await Payment.find({ studentId: payment.studentId });
    const totalDue = studentPayments.reduce((sum, payment) => sum + (payment.amount || 0), 0);
    const totalPaid = studentPayments.reduce((sum, payment) => sum + (payment.amountPaid || 0), 0);
    const balanceRemaining = totalDue - totalPaid;

    // Check if receipt already exists
    let receipt = await Receipt.findOne({ paymentId: paymentId });
    
    if (!receipt) {
      // Generate new receipt with complete student info
      const receiptNumber = `RCP-${Date.now()}-${Math.random().toString(36).substr(2, 6).toUpperCase()}`;
      
      receipt = new Receipt({
        receiptNumber,
        studentId: payment.studentId,
        studentName: student.fullName,    // âœ… Use actual student name
        studentEmail: student.email,      // âœ… Include email
        studentCourse: student.course,    // âœ… Include course
        paymentId: payment._id,
        amount: payment.amountPaid || payment.amount,
        description: payment.description,
        paymentMethod: 'Online Payment',
        status: payment.status === 'completed' ? 'completed' : 'pending',
        date: new Date(),
        items: [{
          description: payment.description,
          amount: payment.amountPaid || payment.amount,
          type: payment.type
        }],
        subtotal: payment.amountPaid || payment.amount,
        tax: 0,
        total: payment.amountPaid || payment.amount
      });

      await receipt.save();
      console.log('New receipt generated with student info:', receiptNumber);
    }

    // âœ… FIX: Ensure we have a valid date
    const receiptDate = receipt.date || new Date();

    // Return enhanced receipt data
    const enhancedReceipt = {
      id: receipt._id,
      receiptNumber: receipt.receiptNumber,
      student: receipt.studentName || student.fullName,
      studentId: receipt.studentId,
      studentEmail: receipt.studentEmail || student.email,    // âœ… Ensure email is included
      studentCourse: receipt.studentCourse || student.course, // âœ… Ensure course is included
      date: receiptDate,
      time: new Date(receiptDate).toLocaleTimeString(),
      paymentMethod: receipt.paymentMethod,
      status: receipt.status,
      items: receipt.items,
      subtotal: receipt.subtotal,
      tax: receipt.tax,
      total: receipt.total,
      paymentDetails: {
        description: payment.description,
        dueDate: payment.dueDate,
        type: payment.type,
        originalAmount: payment.amount,
        amountPaid: payment.amountPaid,
        amountRemaining: payment.amount - payment.amountPaid
      },
      transactionId: `TXN-${receipt._id.toString().slice(-8).toUpperCase()}`,
      balanceInfo: {
        totalDue: totalDue,
        totalPaid: totalPaid,
        balanceRemaining: balanceRemaining
      }
    };

    res.json(enhancedReceipt);
  } catch (error) {
    console.error('Error generating receipt:', error);
    res.status(500).json({ message: 'Failed to generate receipt', error: error.message });
  }
});



// âœ… Get receipt by ID - FIXED VERSION that handles transaction IDs
router.get('/receipt/:receiptId', async (req, res) => {
  try {
    const { receiptId } = req.params;
    
    console.log('ðŸ” Fetching receipt with ID:', receiptId);
    
    // First try to find the receipt by ID in Receipt collection
    let receipt = await Receipt.findById(receiptId);
    
    if (receipt) {
      console.log('âœ… Found receipt in database');
      
      // âœ… Return EXACT database data - no modifications
      const databaseReceipt = {
        id: receipt._id,
        receiptNumber: receipt.receiptNumber,
        student: receipt.studentName,
        studentId: receipt.studentId,
        studentEmail: receipt.studentEmail,
        studentCourse: receipt.studentCourse,
        date: receipt.date,
        time: receipt.date ? new Date(receipt.date).toLocaleTimeString() : 'N/A',
        paymentMethod: receipt.paymentMethod,
        status: receipt.status,
        items: receipt.items || [],
        subtotal: receipt.subtotal,
        tax: receipt.tax,
        total: receipt.total,
        transactionId: receipt.transactionId || `TXN-${receipt._id.toString().slice(-8).toUpperCase()}`,
        balanceInfo: receipt.balanceInfo || {
          totalDue: receipt.subtotal || receipt.total || 0,
          totalPaid: receipt.total || 0,
          balanceRemaining: 0
        }
      };

      return res.json(databaseReceipt);
    }
    
    // âœ… If no receipt found, check if it's a transaction ID
    console.log('ðŸ” No receipt found, checking if it\'s a transaction ID:', receiptId);
    const transaction = await Transaction.findById(receiptId);
    
    if (transaction) {
      console.log('âœ… Found transaction, creating receipt from transaction data');
      
      // Get student information
      const student = await Student.findOne({ studentId: transaction.studentId });
      if (!student) {
        return res.status(404).json({ message: 'Student not found for this transaction' });
      }
      
      // Get payment information
      const payment = await Payment.findById(transaction.paymentId);
      
      // Calculate balances
      const studentPayments = await Payment.find({ studentId: transaction.studentId });
      const totalDue = studentPayments.reduce((sum, p) => sum + (p.amount || 0), 0);
      const totalPaid = studentPayments.reduce((sum, p) => sum + (p.amountPaid || 0), 0);
      const balanceRemaining = Math.max(0, totalDue - totalPaid);
      
      // Create new receipt
      const newReceipt = new Receipt({
        studentId: transaction.studentId,
        studentName: student.fullName,
        studentEmail: student.email,
        studentCourse: student.course,
        paymentId: transaction.paymentId,
        transactionId: transaction.transactionId,
        amount: Math.abs(transaction.amount),
        description: transaction.description,
        paymentMethod: transaction.paymentMethod || 'Online',
        status: 'completed',
        date: transaction.transactionDate || transaction.createdAt,
        items: [{
          description: transaction.description,
          amount: Math.abs(transaction.amount),
          type: payment?.type || 'payment'
        }],
        subtotal: Math.abs(transaction.amount),
        tax: 0,
        total: Math.abs(transaction.amount),
        balanceInfo: {
          totalDue: totalDue,
          totalPaid: totalPaid,
          balanceRemaining: balanceRemaining
        }
      });

      await newReceipt.save();
      console.log('âœ… Created new receipt from transaction:', newReceipt.receiptNumber);
      
      // Return the newly created receipt
      const databaseReceipt = {
        id: newReceipt._id,
        receiptNumber: newReceipt.receiptNumber,
        student: newReceipt.studentName,
        studentId: newReceipt.studentId,
        studentEmail: newReceipt.studentEmail,
        studentCourse: newReceipt.studentCourse,
        date: newReceipt.date,
        time: newReceipt.date ? new Date(newReceipt.date).toLocaleTimeString() : 'N/A',
        paymentMethod: newReceipt.paymentMethod,
        status: newReceipt.status,
        items: newReceipt.items || [],
        subtotal: newReceipt.subtotal,
        tax: newReceipt.tax,
        total: newReceipt.total,
        transactionId: newReceipt.transactionId || `TXN-${newReceipt._id.toString().slice(-8).toUpperCase()}`,
        balanceInfo: newReceipt.balanceInfo
      };

      return res.json(databaseReceipt);
    }
    
    // If neither receipt nor transaction found
    console.log('âŒ No receipt or transaction found with ID:', receiptId);
    return res.status(404).json({ 
      message: 'Receipt not found',
      id: receiptId 
    });
    
  } catch (error) {
    console.error('âŒ Error fetching receipt:', error);
    res.status(500).json({ 
      message: 'Failed to fetch receipt', 
      error: error.message 
    });
  }
});

// Add this function to your financeRoutes.js to update existing receipts

// âœ… Update existing receipts with student information
router.post('/admin/update-receipts-with-student-info', async (req, res) => {
  try {
    console.log('Updating receipts with student information...');
    
    const receipts = await Receipt.find();
    let updatedCount = 0;
    
    for (const receipt of receipts) {
      const student = await Student.findOne({ studentId: receipt.studentId });
      
      if (student) {
        // Update receipt with student information
        receipt.studentName = student.fullName;
        receipt.studentEmail = student.email;
        receipt.studentCourse = student.course;
        
        await receipt.save();
        updatedCount++;
        console.log(`Updated receipt ${receipt.receiptNumber} for student: ${student.fullName}`);
      }
    }
    
    res.json({
      message: `Successfully updated ${updatedCount} receipts with student information`,
      updated: updatedCount,
      total: receipts.length
    });
    
  } catch (error) {
    console.error('Error updating receipts:', error);
    res.status(500).json({ 
      message: 'Failed to update receipts', 
      error: error.message 
    });
  }
});


// âœ… Generate receipts for all existing payments
router.post('/admin/generate-all-receipts', async (req, res) => {
  try {
    console.log('Generating receipts for all payments...');
    
    const payments = await Payment.find({ 
      $or: [
        { amountPaid: { $gt: 0 } },
        { status: 'completed' }
      ]
    });
    
    console.log(`Found ${payments.length} payments to generate receipts for`);
    
    const generatedReceipts = [];
    
    for (const payment of payments) {
      const existingReceipt = await Receipt.findOne({ paymentId: payment._id });
      
      if (!existingReceipt) {
        const receipt = await generateReceipt(
          payment, 
          payment.amountPaid || payment.amount,
          'System Generated'
        );
        
        generatedReceipts.push(receipt);
        console.log(`Generated receipt for: ${payment.studentName} - ${payment.description}`);
      }
    }
    
    res.json({
      message: `Successfully generated ${generatedReceipts.length} receipts`,
      generatedReceipts: generatedReceipts.length,
      details: generatedReceipts.map(r => ({
        receiptNumber: r.receiptNumber,
        student: r.studentName,
        amount: r.total
      }))
    });
    
  } catch (error) {
    console.error('Error generating receipts:', error);
    res.status(500).json({ 
      message: 'Failed to generate receipts', 
      error: error.message 
    });
  }
});


// âœ… Get transaction by ID - UPDATED VERSION with correct field mapping
router.get('/admin/transaction/:transactionId', async (req, res) => {
  try {
    const { transactionId } = req.params;
    
    console.log('Fetching transaction:', transactionId);
    
    const transaction = await Transaction.findById(transactionId);
    if (!transaction) {
      return res.status(404).json({ message: 'Transaction not found' });
    }

    // âœ… FIX: Return fields that match Transaction model
    res.json({
      id: transaction._id,
      transactionId: transaction.transactionId,
      studentId: transaction.studentId,
      // Note: studentName is not in Transaction model, we'll fetch it separately
      description: transaction.description,
      amount: transaction.amount,
      type: transaction.type,
      status: transaction.status,
      date: transaction.transactionDate, // âœ… Use transactionDate from model
      createdAt: transaction.createdAt,
      paymentMethod: transaction.paymentMethod,
      paymentId: transaction.paymentId
    });
  } catch (error) {
    console.error('Error fetching transaction:', error);
    res.status(500).json({ message: 'Failed to fetch transaction', error: error.message });
  }
});



// âœ… Generate receipts for all existing transactions
router.post('/admin/generate-transaction-receipts', async (req, res) => {
  try {
    console.log('Generating receipts for all transactions...');
    
    const transactions = await Transaction.find({
      status: 'completed',
      amount: { $gt: 0 }
    });
    
    console.log(`Found ${transactions.length} transactions to generate receipts for`);
    
    const generatedReceipts = [];
    
    for (const transaction of transactions) {
      const existingReceipt = await Receipt.findOne({ 
        $or: [
          { _id: transaction._id },
          { transactionId: transaction.transactionId }
        ]
      });
      
      if (!existingReceipt) {
        const student = await Student.findOne({ studentId: transaction.studentId });
        const payment = await Payment.findById(transaction.paymentId);
        
        const receipt = new Receipt({
          studentId: transaction.studentId,
          studentName: transaction.studentName,
          studentEmail: student?.email,
          studentCourse: student?.course,
          paymentId: transaction.paymentId,
          transactionId: transaction.transactionId,
          paymentMethod: transaction.paymentMethod || 'Online',
          status: 'completed',
          date: transaction.date || new Date(),
          items: [{
            description: transaction.description,
            amount: Math.abs(transaction.amount),
            type: payment?.type || 'payment'
          }],
          subtotal: Math.abs(transaction.amount),
          tax: 0,
          total: Math.abs(transaction.amount)
        });

        await receipt.save();
        generatedReceipts.push(receipt);
        console.log(`Generated receipt for transaction: ${transaction.transactionId}`);
      }
    }
    
    res.json({
      message: `Successfully generated ${generatedReceipts.length} receipts from transactions`,
      generatedReceipts: generatedReceipts.length
    });
    
  } catch (error) {
    console.error('Error generating transaction receipts:', error);
    res.status(500).json({ 
      message: 'Failed to generate transaction receipts', 
      error: error.message 
    });
  }
});


// âœ… FIXED: Send receipt to student - WORKING VERSION
router.post('/admin/receipts/:receiptId/send', async (req, res) => {
  try {
    const { receiptId } = req.params;
    const { studentId, sendEmail = true } = req.body;
    
    console.log('ðŸ“¤ Sending receipt to student:', { receiptId, studentId, sendEmail });

    // First try to find receipt by ID
    let receipt = await Receipt.findById(receiptId);
    
    // If not found by ID, try to find by transaction ID or other identifier
    if (!receipt) {
      console.log('ðŸ” Receipt not found by ID, trying transaction ID...');
      receipt = await Receipt.findOne({ 
        $or: [
          { transactionId: receiptId },
          { receiptNumber: receiptId },
          { _id: receiptId }
        ]
      });
    }

    if (!receipt) {
      return res.status(404).json({ 
        success: false, 
        message: 'Receipt not found' 
      });
    }

    // Get student information
    const student = await Student.findOne({ 
      studentId: receipt.studentId || studentId 
    });
    
    if (!student) {
      return res.status(404).json({ 
        success: false, 
        message: 'Student not found' 
      });
    }

    // Update receipt to mark it as sent to student
    receipt.sentToStudent = true;
    receipt.sentAt = new Date();
    receipt.studentNotified = true;
    
    await receipt.save();

    // If email sending is enabled, send email notification
    if (sendEmail && student.email && student.email !== 'N/A') {
      try {
        console.log(`ðŸ“§ SENDING EMAIL to: ${student.email}`);
        console.log(`ðŸ“„ Receipt details: ${receipt.receiptNumber} - $${receipt.total}`);
        
        // Simulate email sending (replace with actual email service)
        console.log('âœ… Email sent successfully to student');
        
      } catch (emailError) {
        console.error('âŒ Email sending failed:', emailError);
      }
    }

    console.log('âœ… Receipt successfully sent to student:', student.fullName);
    
    res.json({
      success: true,
      message: 'Receipt sent to student successfully',
      receipt: {
        id: receipt._id,
        receiptNumber: receipt.receiptNumber,
        studentName: student.fullName,
        studentEmail: student.email,
        amount: receipt.total,
        sentAt: receipt.sentAt
      }
    });

  } catch (error) {
    console.error('âŒ Error sending receipt to student:', error);
    res.status(500).json({ 
      success: false, 
      message: 'Failed to send receipt to student', 
      error: error.message 
    });
  }
});

// new guy up


// âœ… Sync receipts for a student
router.post('/student/:studentId/sync-receipts', async (req, res) => {
  try {
    const { studentId } = req.params;
    console.log('ðŸ”„ Syncing receipts for student:', studentId);

    // Find all receipts for this student
    const receipts = await Receipt.find({ studentId });
    
    // Also find receipts that might not have proper studentId but belong to this student
    const student = await Student.findOne({ studentId });
    if (student) {
      const receiptsByStudentName = await Receipt.find({ 
        studentName: student.fullName 
      });
      
      // Update these receipts with proper studentId
      for (const receipt of receiptsByStudentName) {
        if (!receipt.studentId || receipt.studentId === 'N/A') {
          receipt.studentId = studentId;
          receipt.studentEmail = student.email;
          receipt.studentCourse = student.course;
          await receipt.save();
          console.log(`âœ… Updated receipt ${receipt.receiptNumber} with student ID`);
        }
      }
    }

    // Find payments for this student and generate receipts if missing
    const payments = await Payment.find({ studentId, amountPaid: { $gt: 0 } });
    let generatedCount = 0;

    for (const payment of payments) {
      const existingReceipt = await Receipt.findOne({ paymentId: payment._id });
      
      if (!existingReceipt) {
        const receipt = new Receipt({
          receiptNumber: `RCP-${Date.now()}-${Math.random().toString(36).substr(2, 6).toUpperCase()}`,
          studentId: payment.studentId,
          studentName: payment.studentName,
          studentEmail: student?.email,
          studentCourse: student?.course,
          paymentId: payment._id,
          amount: payment.amountPaid,
          description: payment.description,
          paymentMethod: 'Payment',
          status: 'completed',
          date: payment.updatedAt || new Date(),
          items: [{
            description: payment.description,
            amount: payment.amountPaid,
            type: payment.type
          }],
          subtotal: payment.amountPaid,
          tax: 0,
          total: payment.amountPaid
        });

        await receipt.save();
        generatedCount++;
        console.log(`âœ… Generated receipt for payment: ${payment.description}`);
      }
    }

    const finalReceipts = await Receipt.find({ studentId }).sort({ date: -1 });

    res.json({
      success: true,
      message: `Sync completed. Found ${finalReceipts.length} receipts. Generated ${generatedCount} new receipts.`,
      receiptsCount: finalReceipts.length,
      generatedCount: generatedCount,
      receipts: finalReceipts
    });

  } catch (error) {
    console.error('âŒ Error syncing receipts:', error);
    res.status(500).json({ 
      success: false, 
      message: 'Failed to sync receipts', 
      error: error.message 
    });
  }
});

export default router;

